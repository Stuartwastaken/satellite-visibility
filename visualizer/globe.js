/**
 * Starlink Constellation 3D Globe
 * ================================
 * Three.js WebGL renderer for the full multi-shell constellation.
 * Reads window.GLOBE_DATA generated by the C++ visualizer_data binary.
 */

import * as THREE from "three";
import { OrbitControls } from "three/addons/controls/OrbitControls.js";

const GLOBE = window.GLOBE_DATA;
if (!GLOBE) {
  console.warn("GLOBE_DATA not found — run ./visualizer_data first");
}

/* ============================================================
   Shell color palette (matches legend in index.html)
   ============================================================ */
const SHELL_COLORS = [
  new THREE.Color(0xffffff), // 0: Gen1 Main — white
  new THREE.Color(0xcccccc), // 1: Gen1 Backup — light gray
  new THREE.Color(0x4488ff), // 2: Polar — blue
  new THREE.Color(0x44cc44), // 3: SSO — green
  new THREE.Color(0x999999), // 4: Gen2 — medium gray
];

/* ============================================================
   Stats panel
   ============================================================ */
function populateStats() {
  const el = document.getElementById("globe-stats");
  if (!el || !GLOBE) return;

  const card = (label, value) =>
    `<div class="stat-card"><h4>${label}</h4><div class="value">${value}</div></div>`;

  const shells = GLOBE.meta.shells;
  const minAlt = Math.min(...shells.map((s) => s.altitude_km));
  const maxAlt = Math.max(...shells.map((s) => s.altitude_km));

  el.innerHTML = [
    card("Active Satellites", GLOBE.meta.total_satellites.toLocaleString()),
    card("ISL Links", GLOBE.meta.total_isl_links.toLocaleString()),
    card("Orbital Shells", shells.length),
    card("Ground Stations", GLOBE.stations.length),
    card("Altitude Range", `${minAlt} – ${maxAlt} km`),
  ].join("");
}

/* ============================================================
   Scene, Camera, Renderer
   ============================================================ */
let scene, camera, renderer, controls;
let satPoints, islLines, stationPoints;
let animationId = null;

function init() {
  if (!GLOBE) return;

  const container = document.getElementById("globe-container");
  if (!container) return;

  const W = container.clientWidth;
  const H = container.clientHeight || 600;

  // Scene
  scene = new THREE.Scene();

  // Camera
  camera = new THREE.PerspectiveCamera(45, W / H, 0.01, 100);
  camera.position.set(0, 0.6, 3.2);

  // Renderer
  renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
  renderer.setPixelRatio(window.devicePixelRatio);
  renderer.setSize(W, H);
  renderer.setClearColor(0x000000, 1);
  container.appendChild(renderer.domElement);

  // Controls
  controls = new OrbitControls(camera, renderer.domElement);
  controls.enableZoom = false;
  controls.enablePan = false;
  controls.autoRotate = true;
  controls.autoRotateSpeed = 0.3;
  controls.enableDamping = true;
  controls.dampingFactor = 0.05;
  controls.minPolarAngle = 0.2;
  controls.maxPolarAngle = Math.PI - 0.2;

  // Lighting
  const ambient = new THREE.AmbientLight(0x222233, 1.5);
  scene.add(ambient);
  const dir = new THREE.DirectionalLight(0xffffff, 0.6);
  dir.position.set(5, 3, 5);
  scene.add(dir);

  // Build scene objects
  createStarfield();
  createEarth();
  createAtmosphere();
  createSatellites();
  createISLLinks();
  createGroundStations();

  // Resize handler
  window.addEventListener("resize", onResize);

  // Control bindings
  bindControls();

  // Start animation (only when visible)
  observeVisibility();
}

/* ============================================================
   Starfield (subtle background depth)
   ============================================================ */
function createStarfield() {
  const count = 2500;
  const positions = new Float32Array(count * 3);
  for (let i = 0; i < count; i++) {
    const theta = Math.random() * Math.PI * 2;
    const phi = Math.acos(2 * Math.random() - 1);
    const r = 40 + Math.random() * 20;
    positions[i * 3] = r * Math.sin(phi) * Math.cos(theta);
    positions[i * 3 + 1] = r * Math.sin(phi) * Math.sin(theta);
    positions[i * 3 + 2] = r * Math.cos(phi);
  }
  const geom = new THREE.BufferGeometry();
  geom.setAttribute("position", new THREE.BufferAttribute(positions, 3));
  const mat = new THREE.PointsMaterial({
    color: 0xffffff,
    size: 0.05,
    sizeAttenuation: true,
  });
  scene.add(new THREE.Points(geom, mat));
}

/* ============================================================
   Earth (dark procedural sphere)
   ============================================================ */
function createEarth() {
  const geom = new THREE.SphereGeometry(1, 64, 64);
  const mat = new THREE.MeshPhongMaterial({
    color: 0x080c14,
    emissive: 0x020408,
    specular: 0x111122,
    shininess: 15,
    flatShading: false,
  });
  scene.add(new THREE.Mesh(geom, mat));
}

/* ============================================================
   Atmosphere glow (Fresnel edge effect)
   ============================================================ */
function createAtmosphere() {
  const vertexShader = `
    varying vec3 vNormal;
    varying vec3 vPosition;
    void main() {
      vNormal = normalize(normalMatrix * normal);
      vPosition = (modelViewMatrix * vec4(position, 1.0)).xyz;
      gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
    }
  `;
  const fragmentShader = `
    varying vec3 vNormal;
    varying vec3 vPosition;
    void main() {
      vec3 viewDir = normalize(-vPosition);
      float fresnel = 1.0 - dot(viewDir, vNormal);
      fresnel = pow(fresnel, 5.0);
      gl_FragColor = vec4(0.25, 0.4, 0.9, fresnel * 0.3);
    }
  `;

  const geom = new THREE.SphereGeometry(1.012, 64, 64);
  const mat = new THREE.ShaderMaterial({
    vertexShader,
    fragmentShader,
    side: THREE.BackSide,
    blending: THREE.AdditiveBlending,
    transparent: true,
    depthWrite: false,
  });
  scene.add(new THREE.Mesh(geom, mat));
}

/* ============================================================
   Satellites (9,636 points, per-shell coloring)
   ============================================================ */
function createSatellites() {
  const sats = GLOBE.satellites;
  const positions = new Float32Array(sats.length * 3);
  const colors = new Float32Array(sats.length * 3);

  for (let i = 0; i < sats.length; i++) {
    const s = sats[i];
    positions[i * 3] = s.x;
    positions[i * 3 + 1] = s.y;
    positions[i * 3 + 2] = s.z;

    const color = SHELL_COLORS[s.s] || SHELL_COLORS[0];
    colors[i * 3] = color.r;
    colors[i * 3 + 1] = color.g;
    colors[i * 3 + 2] = color.b;
  }

  const geom = new THREE.BufferGeometry();
  geom.setAttribute("position", new THREE.BufferAttribute(positions, 3));
  geom.setAttribute("color", new THREE.BufferAttribute(colors, 3));

  const mat = new THREE.PointsMaterial({
    size: 0.012,
    vertexColors: true,
    sizeAttenuation: true,
    transparent: true,
    opacity: 0.75,
    depthWrite: false,
  });

  satPoints = new THREE.Points(geom, mat);
  scene.add(satPoints);
}

/* ============================================================
   ISL Links (intra-plane ring topology)
   ============================================================ */
function createISLLinks() {
  const links = GLOBE.isl_links;
  const sats = GLOBE.satellites;
  const positions = new Float32Array(links.length * 6);

  // Build id -> index lookup (satellites are in order by id, so id === index)
  for (let i = 0; i < links.length; i++) {
    const [aId, bId] = links[i];
    const a = sats[aId];
    const b = sats[bId];
    positions[i * 6] = a.x;
    positions[i * 6 + 1] = a.y;
    positions[i * 6 + 2] = a.z;
    positions[i * 6 + 3] = b.x;
    positions[i * 6 + 4] = b.y;
    positions[i * 6 + 5] = b.z;
  }

  const geom = new THREE.BufferGeometry();
  geom.setAttribute("position", new THREE.BufferAttribute(positions, 3));

  const mat = new THREE.LineBasicMaterial({
    color: 0xffffff,
    transparent: true,
    opacity: 0.08,
    depthWrite: false,
  });

  islLines = new THREE.LineSegments(geom, mat);
  scene.add(islLines);
}

/* ============================================================
   Ground Stations (20 red points on Earth surface)
   ============================================================ */
function createGroundStations() {
  const stations = GLOBE.stations;
  const positions = new Float32Array(stations.length * 3);

  for (let i = 0; i < stations.length; i++) {
    const gs = stations[i];
    positions[i * 3] = gs.x;
    positions[i * 3 + 1] = gs.y;
    positions[i * 3 + 2] = gs.z;
  }

  const geom = new THREE.BufferGeometry();
  geom.setAttribute("position", new THREE.BufferAttribute(positions, 3));

  const mat = new THREE.PointsMaterial({
    color: 0xcc0000,
    size: 0.045,
    sizeAttenuation: true,
    depthWrite: false,
  });

  stationPoints = new THREE.Points(geom, mat);
  scene.add(stationPoints);
}

/* ============================================================
   Controls binding
   ============================================================ */
function bindControls() {
  const linksToggle = document.getElementById("globe-show-links");
  const stationsToggle = document.getElementById("globe-show-stations");
  const rotateToggle = document.getElementById("globe-auto-rotate");

  if (linksToggle) {
    linksToggle.addEventListener("change", () => {
      if (islLines) islLines.visible = linksToggle.checked;
    });
  }
  if (stationsToggle) {
    stationsToggle.addEventListener("change", () => {
      if (stationPoints) stationPoints.visible = stationsToggle.checked;
    });
  }
  if (rotateToggle) {
    rotateToggle.addEventListener("change", () => {
      if (controls) controls.autoRotate = rotateToggle.checked;
    });
  }
}

/* ============================================================
   Animation loop (only when Constellation tab is visible)
   ============================================================ */
function animate() {
  animationId = requestAnimationFrame(animate);
  controls.update();
  renderer.render(scene, camera);
}

function startAnimation() {
  if (animationId === null) animate();
}

function stopAnimation() {
  if (animationId !== null) {
    cancelAnimationFrame(animationId);
    animationId = null;
  }
}

function observeVisibility() {
  const panel = document.getElementById("constellation");
  if (!panel) return;

  // Initial check
  if (panel.classList.contains("active")) startAnimation();

  // Observe tab switches via MutationObserver on the class attribute
  const observer = new MutationObserver(() => {
    if (panel.classList.contains("active")) {
      startAnimation();
      onResize(); // re-fit in case container resized while hidden
    } else {
      stopAnimation();
    }
  });
  observer.observe(panel, { attributes: true, attributeFilter: ["class"] });
}

/* ============================================================
   Resize handler
   ============================================================ */
function onResize() {
  const container = document.getElementById("globe-container");
  if (!container || !renderer) return;
  const W = container.clientWidth;
  const H = container.clientHeight || 600;
  camera.aspect = W / H;
  camera.updateProjectionMatrix();
  renderer.setSize(W, H);
}

/* ============================================================
   Bootstrap
   ============================================================ */
document.addEventListener("DOMContentLoaded", () => {
  populateStats();
  init();
});
